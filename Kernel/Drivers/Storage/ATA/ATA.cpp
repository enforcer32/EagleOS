#include <Kernel/Drivers/Storage/ATA/ATA.h>
#include <Kernel/Arch/x86/IO.h>
#include <Kernel/Kern/KPrintf.h>

/* Bus Ports */
#define ATA_PRIMARY_BUS_IOPORT 0x1F0 // 0x1F0 - 0x1F7
#define ATA_SECONDARY_BUS_IOPORT 0x170 // 0x170 - 0x177

/* Registers - Offset from Bus Ports */
#define ATA_DATA_REG 0x0 // PIO data bytes (R/W)
#define ATA_ERROR_REG 0x1 // Retrieve Error Generated by Last Command (R)
#define ATA_FEATURES_REG 0x1 // Control Command Specific Features (W)
#define ATA_SECTOR_COUNT_REG 0x2 // Number of Sectors to Read/Write (0 Special) (R/W)
#define ATA_LBA_LOW_REG  // Partial Disk Sector Address (R/W)
#define ATA_LBA_MID_REG 0x4 // Partial Disk Sector Address (R/W)
#define ATA_LBA_HIGH_REG 0x5 // Partial Disk Sector Address (R/W)
#define ATA_DRIVEHEAD_SELECT_REG 0x6 // Select Drive/Head (R/W)
#define ATA_STATUS_REG 0x7 // Read Current Status (R)
#define ATA_COMMAND_REG 0x7 // Send ATA Commands to Device (W)

#define ATA_ALTSTATUS_REG 0xC // Alternate Status Register (Doesn't Affect Interrupts) (R)
#define ATA_DEVICE_CONTROL_REG 0xC // Reset Bus or Enable/Disable INterrupts (W)
#define ATA_DRIVE_ADDRESS_REG 0xD // Provide Drive/Head Select Info (R)

/* Error Register */
#define ATA_ERROR_REG_AMNF 0x01 // Address Mark Not Found
#define ATA_ERROR_REG_TKZNF 0x02 // Track zero not found
#define ATA_ERROR_REG_ABRT 0x04 // Aborted command
#define ATA_ERROR_REG_MCR 0x08 // Media change request
#define ATA_ERROR_REG_IDNF 0x10 // ID not found
#define ATA_ERROR_REG_MC 0x20 // Media changed
#define ATA_ERROR_REG_UNC 0x40 // Uncorrectable data error
#define ATA_ERROR_REG_BBK 0x80 // Bad Block detected

/* Drive/Head Select Register */
#define ATA_DRIVEHEAD_SELECT_REG_DRV 0x10 // Selects Drive Number
#define ATA_DRIVEHEAD_SELECT_REG_LBA 0x40 // If Set uses LBA, Otherwise CHS

/* Status Register */
#define ATA_STATUS_REG_ERR 0x01 // Error Occursed, Send New Command to Clear it/(OR Software Reset)
#define ATA_STATUS_REG_IDX 0x02 // Index, Always 0
#define ATA_STATUS_REG_CORR 0x04 // Corrected data, Always 0
#define ATA_STATUS_REG_DRQ 0x08 // Set when the drive has PIO data to transfer, or is ready to accept PIO data
#define ATA_STATUS_REG_SRV 0x10 // Overlapped Mode Service Request
#define ATA_STATUS_REG_DF 0x20 // Drive Fault Error (does not set ERR)
#define ATA_STATUS_REG_DRDY 0x40 // Bit is clear when drive is spun down, or after an error. Set otherwise
#define ATA_STATUS_REG_BSY 0x80 // Indicates Drive is Preparing to send/receive data (wait for it to clear). In case of 'hang' (it never clears), do a software reset

/* Device Control Register */
#define ATA_DEVICE_CONTROL_REG_nIEN 0x02 // Set this to stop Current Device from sending interrupts
#define ATA_DEVICE_CONTROL_REG_SRST 0x04 // Set, then clear (after 5us), this to do a "Software Reset" on all ATA drives on a bus, if one is misbehaving
#define ATA_DEVICE_CONTROL_REG_HOB 0x80 // Set this to read back the High Order Byte of the last LBA48 value sent to an IO port

/* Device Address Register */
#define ATA_DRIVE_ADDRESS_REG_DS0 0x1 // Drive 0 select. Clears when drive 0 selected
#define ATA_DRIVE_ADDRESS_REG_DS1 0x2 // Drive 0 select. Clears when drive 0 selected
#define ATA_DRIVE_ADDRESS_REG_HS0 (0x3C >> 2) // One's compliment representation of the currently selected head
#define ATA_DRIVE_ADDRESS_REG_WTG 0x40 // Write gate; goes low while writing to the drive is in progress

/* General ATA INFO */
#define ATA_SECTOR_SIZE 0x200

namespace Kernel
{
	namespace Storage
	{
		bool ATA::Init(ATABus bus, ATADrive drive)
		{
			KPrintf("Initializing ATA Interface for Bus: %s, Drive: %s\n", ((bus == ATABus::Primary) ? "Primary" : "Secondary"), ((drive == ATADrive::Master) ? "Master" : "Slave"));
			m_SectorSize = ATA_SECTOR_SIZE;
			m_Bus = bus;
			m_Drive = drive;

			if (!BusHasDrives(bus))
			{
				KPrintf("ATA->Init Failed, Bus: %s Has No Drives!\n", ((bus == ATABus::Primary) ? "Primary" : "Secondary"));
				return false;
			}

			if (!InitBusDrive())
			{
				KPrintf("ATA->Init Failed to Initialize, Bus: %s, Drive: %s!\n", ((bus == ATABus::Primary) ? "Primary" : "Secondary"), ((drive == ATADrive::Master) ? "Master" : "Slave"));
				return false;
			}

			return true;
		}

		bool ATA::InitBusDrive()
		{
			return true;
		}

		bool ATA::BusHasDrives(ATABus bus)
		{
			if (m_Bus == ATABus::Primary)
				return (x86::IO::INSB((ATA_PRIMARY_BUS_IOPORT + ATA_STATUS_REG)) != 0xFF);
			else if (m_Bus == ATABus::Secondary)
				return (x86::IO::INSB((ATA_SECONDARY_BUS_IOPORT + ATA_STATUS_REG)) != 0xFF);
			return false;
		}
	}
}
